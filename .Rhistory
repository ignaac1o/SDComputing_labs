list_a[1]
list_a$1
list_a
list_a[[1]]
rescale(list_a[[1]])
list_a=list(c(2:5),c(6,9,10,12),c(11:14),c(21,24,25,26))
no_cores=detectCores()
registerDoParallel(makeCluster(no_cores))
foreach(i=1:length(list_a)) %dopar% rescale(list_a[[i]])
stopImplicitCluster()
list_a
rescale(lista_a[[1]])
rescale(list_a[[1]])
list_a=list(c(2:5),c(6,9,10,12),c(11:14),c(21,24,25,26))
no_cores=detectCores()
registerDoParallel(makeCluster(no_cores))
newlist=foreach(i=1:length(list_a)) %dopar% rescale(list_a[[i]])
stopImplicitCluster()
library(scales)
list_a=list(c(2:5),c(6,9,10,12),c(11:14),c(21,24,25,26))
no_cores=detectCores()
registerDoParallel(makeCluster(no_cores))
newlist=foreach(i=1:length(list_a)) %dopar% rescale(list_a[[i]])
stopImplicitCluster()
list_a=list(c(2:5),c(6,9,10,12),c(11:14),c(21,24,25,26))
no_cores=detectCores()
registerDoParallel(makeCluster(no_cores))
resc=function(x){
row=unlist(x)
row=(row-min(row)/(max(row)-min(row))
}
newlist=foreach(i=1:length(list_a)) %dopar% resc(list_a[[i]])
stopImplicitCluster()
list_a
resc=function(x){
row=unlist(x)
row=(row-min(row)/(max(row)-min(row))
}
resc=function(x){
row=unlist(x)
row=(row-min(row))/(max(row)-min(row))
}
list_a=list(c(2:5),c(6,9,10,12),c(11:14),c(21,24,25,26))
no_cores=detectCores()
registerDoParallel(makeCluster(no_cores))
resc=function(x){
row=unlist(x)
row=(row-min(row))/(max(row)-min(row))
}
newlist=foreach(i=1:length(list_a)) %dopar% resc(list_a[[i]])
stopImplicitCluster()
newlisrt
newlist
fviz_nbclust(data5k, kmeans, method = "wss")
library(factoextra)
fviz_nbclust(data5k, kmeans, method = "wss")
slope=fviz_nbclust(data5k, kmeans, method = "wss")
slope
View(slope)
slope[data][y]
slope[data]
slope[[data]]
slope$data$y
slope$data$clusters
slope=function(lista){
clust=lista$data$clusters
y=lista$data$y
for(i in 1:(1-length(lista$data$clusters))){
slope[i]=y[i]-y[i+1]
}
return(slope)
}
slopes=function(lista){
clust=lista$data$clusters
y=lista$data$y
for(i in 1:(1-length(lista$data$clusters))){
slope[i]=y[i]-y[i+1]
}
return(slope)
}
slopes(slope)
slopes=function(x,y){
for(i in 1:(1-length(x))){
slope[i]=y[i]-y[i+1]
}
return(slope)
}
slope$data$clusters
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Mixture parameters
mu_1 <- rep(1, 2)
mu_2 <- rep(-1.5, 2)
Sigma_1 <- matrix(c(1, -0.75, -0.75, 3), nrow = 2, ncol = 2)
Sigma_2 <- matrix(c(2, 0.75, 0.75, 3), nrow = 2, ncol = 2)
Sigma_1_inv <- solve(Sigma_1)
Sigma_2_inv <- solve(Sigma_2)
w <- 0.45
# Density
f <- function(x) {
w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2)
}
# Gradient (caution: only works adequately for x a vector, it is not
# vectorized; observe that in the Sigma_inv %*% (x - mu) part the subtraction
# of mu and premultiplication by Sigma_inv are specific to a *single* point x)
Df <- function(x) {
-(w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) *
Sigma_1_inv %*% (x - mu_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2) *
Sigma_2_inv %*% (x - mu_2))
}
# Plot density
ks::plotmixt(mus = rbind(mu_1, mu_2), Sigmas = rbind(Sigma_1, Sigma_2),
props = c(w, 1 - w), display = "filled.contour2",
gridsize = rep(251, 2), xlim = c(-5, 5), ylim = c(-5, 5),
cont = seq(0, 90, by = 10), col.fun = viridis::viridis)
# Euler solution
x <- c(-2, 2)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.5
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Euler solution
x <- c(-5, 5)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.5
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Euler solution
x <- c(-0,0)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.5
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Euler solution
x <- c(-8,8)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.5
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Euler solution
x <- c(-2,2)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.5
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Euler solution
x <- c(-2,2)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.8
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Euler solution
x <- c(-2,2)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.1
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Euler solution
x <- c(-2,2)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.1
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Mixture parameters
mu_1 <- rep(1, 2)
mu_2 <- rep(-1.5, 2)
Sigma_1 <- matrix(c(1, -0.75, -0.75, 3), nrow = 2, ncol = 2)
Sigma_2 <- matrix(c(2, 0.75, 0.75, 3), nrow = 2, ncol = 2)
Sigma_1_inv <- solve(Sigma_1)
Sigma_2_inv <- solve(Sigma_2)
w <- 0.45
# Density
f <- function(x) {
w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2)
}
# Gradient (caution: only works adequately for x a vector, it is not
# vectorized; observe that in the Sigma_inv %*% (x - mu) part the subtraction
# of mu and premultiplication by Sigma_inv are specific to a *single* point x)
Df <- function(x) {
-(w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) *
Sigma_1_inv %*% (x - mu_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2) *
Sigma_2_inv %*% (x - mu_2))
}
# Plot density
ks::plotmixt(mus = rbind(mu_1, mu_2), Sigmas = rbind(Sigma_1, Sigma_2),
props = c(w, 1 - w), display = "filled.contour2",
gridsize = rep(251, 2), xlim = c(-5, 5), ylim = c(-5, 5),
cont = seq(0, 90, by = 10), col.fun = viridis::viridis)
# Euler solution
x <- c(-2,2)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.1
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Mixture parameters
mu_1 <- rep(1, 2)
mu_2 <- rep(-1.5, 2)
Sigma_1 <- matrix(c(1, -0.75, -0.75, 3), nrow = 2, ncol = 2)
Sigma_2 <- matrix(c(2, 0.75, 0.75, 3), nrow = 2, ncol = 2)
Sigma_1_inv <- solve(Sigma_1)
Sigma_2_inv <- solve(Sigma_2)
w <- 0.45
# Density
f <- function(x) {
w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2)
}
# Gradient (caution: only works adequately for x a vector, it is not
# vectorized; observe that in the Sigma_inv %*% (x - mu) part the subtraction
# of mu and premultiplication by Sigma_inv are specific to a *single* point x)
Df <- function(x) {
-(w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) *
Sigma_1_inv %*% (x - mu_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2) *
Sigma_2_inv %*% (x - mu_2))
}
# Plot density
ks::plotmixt(mus = rbind(mu_1, mu_2), Sigmas = rbind(Sigma_1, Sigma_2),
props = c(w, 1 - w), display = "filled.contour2",
gridsize = rep(251, 2), xlim = c(-5, 5), ylim = c(-5, 5),
cont = seq(0, 90, by = 10), col.fun = viridis::viridis)
# Euler solution
x <- c(-2,2)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.8
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Mixture parameters
mu_1 <- rep(1, 2)
mu_2 <- rep(-1.5, 2)
Sigma_1 <- matrix(c(1, -0.75, -0.75, 3), nrow = 2, ncol = 2)
Sigma_2 <- matrix(c(2, 0.75, 0.75, 3), nrow = 2, ncol = 2)
Sigma_1_inv <- solve(Sigma_1)
Sigma_2_inv <- solve(Sigma_2)
w <- 0.45
# Density
f <- function(x) {
w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2)
}
# Gradient (caution: only works adequately for x a vector, it is not
# vectorized; observe that in the Sigma_inv %*% (x - mu) part the subtraction
# of mu and premultiplication by Sigma_inv are specific to a *single* point x)
Df <- function(x) {
-(w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) *
Sigma_1_inv %*% (x - mu_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2) *
Sigma_2_inv %*% (x - mu_2))
}
# Plot density
ks::plotmixt(mus = rbind(mu_1, mu_2), Sigmas = rbind(Sigma_1, Sigma_2),
props = c(w, 1 - w), display = "filled.contour2",
gridsize = rep(251, 2), xlim = c(-5, 5), ylim = c(-5, 5),
cont = seq(0, 90, by = 10), col.fun = viridis::viridis)
# Euler solution
x <- c(-2,2)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 0.95
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
# Mixture parameters
mu_1 <- rep(1, 2)
mu_2 <- rep(-1.5, 2)
Sigma_1 <- matrix(c(1, -0.75, -0.75, 3), nrow = 2, ncol = 2)
Sigma_2 <- matrix(c(2, 0.75, 0.75, 3), nrow = 2, ncol = 2)
Sigma_1_inv <- solve(Sigma_1)
Sigma_2_inv <- solve(Sigma_2)
w <- 0.45
# Density
f <- function(x) {
w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2)
}
# Gradient (caution: only works adequately for x a vector, it is not
# vectorized; observe that in the Sigma_inv %*% (x - mu) part the subtraction
# of mu and premultiplication by Sigma_inv are specific to a *single* point x)
Df <- function(x) {
-(w * mvtnorm::dmvnorm(x = x, mean = mu_1, sigma = Sigma_1) *
Sigma_1_inv %*% (x - mu_1) +
(1 - w) * mvtnorm::dmvnorm(x = x, mean = mu_2, sigma = Sigma_2) *
Sigma_2_inv %*% (x - mu_2))
}
# Plot density
ks::plotmixt(mus = rbind(mu_1, mu_2), Sigmas = rbind(Sigma_1, Sigma_2),
props = c(w, 1 - w), display = "filled.contour2",
gridsize = rep(251, 2), xlim = c(-5, 5), ylim = c(-5, 5),
cont = seq(0, 90, by = 10), col.fun = viridis::viridis)
# Euler solution
x <- c(-2,2)
# x <- c(-4, 0)
# x <- c(-4, 4)
N <- 1e3
h <- 100
phi <- matrix(nrow = N + 1, ncol = 2)
phi[1, ] <- x
for (t in 1:N) {
phi[t + 1, ] <- phi[t, ] + h * Df(phi[t, ])# / f(phi[t, ])
}
lines(phi, type = "l")
points(rbind(x), pch = 19)
text(rbind(x), labels = "x", pos = 3)
# Mean of the components
points(rbind(mu_1, mu_2), pch = 16, col = 4)
text(rbind(mu_1, mu_2), labels = expression(mu[1], mu[2]), pos = 4, col = 4)
# The modes are different from the mean of the components! -- see the gradients
cbind(Df(mu_1), Df(mu_2))
# Modes
xi_1 <- optim(par = mu_1, fn = function(x) sum(Df(x)^2))$par
xi_2 <- optim(par = mu_2, fn = function(x) sum(Df(x)^2))$par
points(rbind(xi_1, xi_2), pch = 16, col = 2)
text(rbind(xi_1, xi_2), labels = expression(xi[1], xi[2]), col = 2, pos = 2)
