# -*- coding: utf-8 -*-
"""k-means_def.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MbvEqyQbmmvYybW88SHX-TgYEJgTrY6u
"""

# Import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sb
from sklearn.cluster import KMeans
from sklearn.metrics import pairwise_distances_argmin_min
import os
import seaborn as sns
import time
import multiprocessing as mp

# Load the dataset
data = pd.read_csv("computers.csv").iloc[:,1:7] # We discard the index (first column) and categorical variables

# Function to standarize dataset
def standarize_data(data_input):
    return data_input.apply(lambda x: (x-x.mean())/ x.std())
data_norm = standarize_data(data)
# Check if mean is equal to zero in all variables
print(data_norm.mean())

# Function to initialize centroids randomly
def initialize_centroids(k, data):
    """
    This function initialize centroids randomly. In particular, this function choose an observation at random 
    and assigns it as a centroid.
    k: number of clusters.
    data: dataset.
    """
    return data_norm.sample(n=k, random_state=1).reset_index(drop=True)

def assign_obs(data, centroids):
    """
    It calculates the distance between centroids and each observation of the dataset. Finally, it assigns each
    observation to the nearest cluster. It returns two lists: a list which contains the assignments and other list 
    with the distance associated. 
    data: dataset.
    centroids: the observations which work as centroids.
    """

    n = len(data)
    k = len(centroids)
    assignment , distance_associated = ([],[])

    for observation in range(n):
        distances = []
        for centroid in range(k):
            dist = np.sqrt(np.sum(np.square((centroids.iloc[centroid,])-(data.iloc[observation,]))))
            distances.append(dist)

        assignment.append(distances.index(min(distances)))
        distance_associated.append(min(distances))

    return (assignment,distance_associated)

def cluster_iterations(data, k):
    '''
    It computes several iterations relocating centroids to achieve the final distribution of clusters.
    data: dataset
    k: number of clusters
    '''

    # Initialize centroids and error
    centroids = initialize_centroids(k, data)
    error = []
    it = 0

    for i in range(10000):
      data['centroid'], errors_i = assign_obs(data, centroids)
      error.append(sum(errors_i))
      centroids = data.groupby('centroid').agg('mean').reset_index(drop = True)
      it += 1
      if it > 2:
        if(round(error[i],4) ==  round(error[i-1],4)):
            break
        else:
            continue

    data['centroid'], errors_i = assign_obs(data,centroids)
    error.append(sum(errors_i))
    return error[-1]

#Elbow Graph
start = time.time()
squares = np.array([])
n = 10
for i in range(n):
  squares = np.append(squares, cluster_iterations(data_norm,i+1))
end = time.time()
print("Time elapsed:",end - start,"seconds")
plt.figure(figsize=(10,5))
plt.title("Elbow Graph")
plt.plot(range(1,n+1), squares)
plt.show()

# k=2, optimal clusters number
# Run the algorithm with k=2
# We measure time with time
k_final = 2
start = time.time()
cluster_iterations(data_norm, k_final)
end = time.time()
print("Time elapsed:",end - start,"seconds")

# Plot the first two dimensions of the clusters
sns.scatterplot(x="price", y="speed", hue="centroid",data=data_norm)

# We see the cluster with largest average price
mean = []
for i in range(k_final-1):
  mean.append(np.mean(data_norm['price'].loc[(data_norm.centroids == i)]))
  print("The cluster with the largest average price is", mean.index(max(mean)), "with mean", min(mean))

# Print a heat map
sns.heatmap(data_norm.groupby('centroid').agg('mean').reset_index(drop = True))

start = time.time()
pool = mp.Pool(mp.cpu_count())
n = 10
squares_mp = [pool.apply(cluster_iterations, args=(data_norm,i+1)) for i in range(n)]
pool.close() 
end = time.time()
print("Time elapsed:",end - start,"seconds")

plt.figure(figsize=(10,5))
plt.title("Elbow Graph")
plt.plot(range(1,n+1), squares_mp)
plt.show()

